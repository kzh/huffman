encode:
    mov r15, [rsp + 8]
    push r15

    call count
    call sort
    call tree
    call generate

    ; Print 
    push rcx
    push rax
    call print
    add rsp, 0x10

    call print_line

    add rsp, 0x8
    ret

; `count` takes in a c string parameter from the stack and records the frequency of each unique characters in the string.
; It returns the memory address of the structured data consisting of the characters along with their frequencies in the rax register.
; The memory layout for this return structure will be:
;
; struct {
;     int uniqueCharactersCount; // 4 bytes
;     struct {
;         bool isNode;    // 1 byte, used later for tree gen
;         char character; // 1 byte
;         int frequency;  // 4 bytes
;     } frequencies[];
; }
;
; This procedure utilizes the following registers: rax for memory references, rsi for 
; string operations, rcx for loop counters, rbx for address calculations, and r15 as
; a temporary register for purposes such as acting as a buffer to transfer memory or
; passing arguments to the stack.
count:
    push rbp
    mov rbp, rsp
     
    ; Allocate memory
    mov r15, 0x1000 ; 4096 bytes / 1 mem page
    push r15
    call mmap
    add rsp, 0x8

    ; Retrieve string argument
    mov rsi, [rbp + 16]

    ; Store zero for starting uniqueCharactersCount value
    mov dword [rax], 0 
    
    ; Set loop counter to 0 
    xor rcx, rcx

; Loop through each letter in the string
.loop:
    mov dl, [rsi + rcx] ; Fetch current letter to process
    cmp dl, 0           ; Check if null character
    je .exit            ; If so, end loop

    push rcx            ; Save counter to prepare for inner loop
    xor rcx, rcx        ; Start count at zero

; Search if array has existing entry for this character 
.search_loop:
    cmp dword [rax], ecx ; Check if reached end of array
    je .search_add       ; Jump to create new character entry

    ; Calculate memory address of character entry
    imul rbx, rcx, 0x6
    add rbx, rax 
    add rbx, 0x4

    cmp dl, byte [rbx + 1] ; Check if characters are equal
    jne .search_continue   ; If not, move on to next character

    ; Found existing character entry, so add one to the frequency count
    mov r15d, dword [rbx + 2]
    inc r15d 
    mov [rbx + 2], r15d 
    jmp .search_exit

.search_continue:
    inc ecx ; Move to next character entry
    jmp .search_loop

; Create new character entry
.search_add:
    ; Increase uniqueCharactersCount
    mov ebx, [rax]
    inc ebx
    mov [rax], dword ebx

    ; Calculate memory address of character entry
    imul rbx, rcx, 0x6
    add rbx, rax 
    add rbx, 0x4

    ; Set character entry data
    mov byte [rbx], 0x0
    mov [rbx + 1], dl
    mov dword [rbx + 2], 0x1

.search_exit:
    pop rcx ; Restore counter register for outer loop (characters loop)
    inc rcx ; Move to next character 
    jmp .loop

.exit:
    mov rsp, rbp
    pop rbp
    ret

; `sort` takes in a character frequency structure generated by `count` as a parameter through the rax register.
; It then performs insertion sort on the character frequency array. Charcters with a greater frequency and
; greater ascii value will be placed farther right.
;
; This procedure utilizes the following registers: rcx for loop counters, and r13, r14, and r15 for calculations and
; memory copying.
sort:
    ; Set loop counter to 0 
    xor rcx, rcx

; Loop through each character entry
.loop:
    inc rcx ; Move to next character entry

    cmp ecx, dword [rax] ; Check if reached end of character entries
    je .exit

    ; Calculate memory address of selected character entry
    imul r15, rcx, 0x6
    add r15, rax
    add r15, 0x4

    ; Retrieve frequency of selected character
    mov r13d, dword [r15 + 2] 

    ; Save loop counter to prepare to enter inner loop
    push rcx

; Loop backwards from current character entry and search for optimal location
; placement of character entry where the character entry has a greater frequency
; than the character entry before and lower frequency than the character entry
; following. On the condition, the frequencies are equal, ascii value will be compared instead.
.search:
    dec rcx ; Move to previous character entry

    cmp rcx, -0x1 ; Check if reached start of character entries
    je .search_exit

    ; Calculate memory address of character entry
    imul r14, rcx, 0x6
    add r14, rax
    add r14, 0x4

    cmp r13d, dword [r14 + 2] ; Check if selected has greater frequency 
    jg .search_exit           ; If so, end search

    cmp r13d, dword [r14 + 2] ; Check if selected has unequal frequency
    jne .swap                 ; If so, swap

    mov r12b, byte [r15 + 1]  ; Retrieve ascii value of selected
    cmp r12b, byte [r14 + 1]  ; Check if selected has greater ascii value
    jg .search_exit           ; If so, end search

; Swap character entries at r14 and 15
.swap:
    ; Swap frequencies
    mov r12d, [r14 + 2]
    mov [r14 + 2], r13d
    mov [r15 + 2], r12d

    ; Swap characters
    mov r11b, [r15 + 1]
    mov r12b, [r14 + 1]
    mov [r14 + 1], r11b
    mov [r15 + 1], r12b

    mov r15, r14
    jmp .search

.search_exit:
    pop rcx ; Restore counter register for outer loop
    jmp .loop

.exit:
    ret

; `tree` constructs a huffman tree based on a character frequnecy map passed in as a parameter through
; the rax register. Characters with greater frequency will have less depth in the tree so less bits are
; needed to reach the character. The tree is returned in the rax register.
;
; This procedure utilizes the following registers: rcx for loop counters, r11, r12, r13, and r14 for
; memory references, and r8, r9, r10, and r15 as temeporary registers for calculations.
tree:
    mov r11, rax ; Store character frequency map location in r11

    ; Allocate space for leaves heap
    imul r15d, dword [r11], 0x8 
    push r15     ; Load space parameter onto stack
    call mmap
    mov r12, rax ; Store leaves heap location in r12
    add rsp, 0x8 ; Clear parameter off stack
    
    lea r15, [r11 + 0x4]
    xor rcx, rcx ; Set counter register to zero

; Populate leaves heap with character frequencies entry
.base:
    mov [r12 + rcx * 8], r15 ; Move memory address of leaf into heap

    ; Move to next leaf 
    add r15, 0x6
    inc rcx

    ; Check if reached end of character frequency map 
    cmp ecx, dword [r11]
    jne .base 

    ; Check for only one leaf, if so no need to build tree
    cmp rcx, 0x1
    jle .exit

    call create_tree
    mov r13, rax

; Start constructing tree from the leaves
.construct:
    ; Create tree node with first two items in heap
    mov r15, [r12 + 8]
    push r15              ; Load right child argument with first item in heap
    mov r15, [r12]
    push r15              ; Load left child argument
    push r13              ; Load tree argument
    call tree_create_node
    add rsp, 0x18         ; Clear arguments off stack
    mov r14, rax          ; Store returning tree node in r14

    ; Retrieve tree node frequency
    push r14      ; Load tree node argument 
    call tree_node_get_freq
    mov r10d, eax ; Store returning frequency in r10d
    add rsp, 0x8  ; Clear arguments off stack

    add r12, 0x8   ; Remove first item in heap
    mov [r12], r14 ; Store new tree node in heap

    
    mov r8, r12 ; Address for sort index
    mov r9, 0x1 
    dec rcx

    cmp rcx, 0x1 
    je .exit

; Resort tree node into the heap
.insert:
    ; Retrieve frequency of next tree node
    mov rax, [r8 + 8]
    push rax
    call tree_node_get_freq
    add rsp, 0x8

    ; Compare current frequency and frequency of next tree node
    cmp eax, r10d
    jge .construct

    ; Swap current tree node and next tree node
    mov r15, [r8 + 8]
    mov [r8], r15 
    mov [r8 + 8], r14

    ; Move to next tree node
    add r8, 0x8
    inc r9

    ; Check if reached end of tree nodes
    cmp r9, rcx 
    jne .insert
    jmp .construct

.exit:
    mov rax, [r12]
    ret

generate:
    push rbp
    mov rbp, rsp

    ; Allocate space to build string
    push rax
    mov r15, 0x1000
    push r15
    call mmap
    mov r12, rax
    add rsp, 0x8
    pop rax

    xor r11, r11    ; Store string length (used allocated space)
    mov r10, 0x1000 ; Store max string length (total allocated space)

    ; Serialize tree
    call tree_serialize

    ; Encode string
    mov r15, [rbp + 16] ; Retrieve string argument
    push r15 
    call tree_encode_str
    add rsp, 0x8

    ; Set return values of string location and string length
    mov rax, r12 
    mov rcx, r11
    
    mov rsp, rbp
    pop rbp
    ret
